## <a name="Demand-Attach File-Server (DAFS)"></a> Demand-Attach File-Server (DAFS)

OpenAFS 1.5 contains Demand-Attach File-Server (DAFS). DAFS is a significant departure from the more _traditional_ AFS file-server and this document details those changes.

<div>
  <ul>
    <li><a href="#Demand-Attach File-Server (DAFS)"> Demand-Attach File-Server (DAFS)</a></li>
    <li><a href="#Why Demand-Attach File-Server (D"> Why Demand-Attach File-Server (DAFS) ?</a></li>
    <li><a href="#An Overview of Demand-Attach Fil"> An Overview of Demand-Attach File-Server</a></li>
    <li><a href="#The Gory Details of the Demand-A"> The Gory Details of the Demand-Attach File-Server</a><ul>
        <li><a href="#File-server Start-up / Shutdown"> File-server Start-up / Shutdown Sequence</a></li>
        <li><a href="#Volume Finite-State Automata"> Volume Finite-State Automata</a></li>
        <li><a href="#Volume Least Recently Used (VLRU"> Volume Least Recently Used (VLRU) Queues</a></li>
        <li><a href="#Vnode Finite-State Automata"> Vnode Finite-State Automata</a></li>
        <li><a href="#Demand Salvaging"> Demand Salvaging</a></li>
        <li><a href="#File-Server Host / Callback Stat"> File-Server Host / Callback State</a></li>
      </ul>
    </li>
    <li><a href="#File-Server Arguments (relating"> File-Server Arguments (relating to Demand-Attach)</a></li>
  </ul>
</div>

## <a name="Why Demand-Attach File-Server (D"></a> Why Demand-Attach File-Server (DAFS) ?

On a traditional file-server, volumes are attached at start-up and detached only at shutdown. Any attached volume can be modified and changes are periodically flushed to disk or on shutdown. When a file-server isn't shutdown cleanly, the integrity of every attached volume has to be verified by the salvager, whether the volume had been modified or not. As file-servers grow larger (and the number of volumes increase), the length of time required to salvage and attach volumes increases, e.g. it takes around two hours for a file-server housing 512GB data to salvage and attach volumes !

On a Demand-Attach File-Server (DAFS), volumes are attached only when accessed by clients. On start-up, the file-server reads only the volume headers to determine what volumes reside on what partitions. When accessed by clients, the volumes are attached. After some period of inactivity, volumes are automatically detached. This dramatically improves start-up and shutdown times. A demand-attach file-server can be restarted in seconds compared to hours for the same traditional file-server.

The primary objective of the demand-attach file-server was to dramatically reduce the amount of time required to restart an AFS file-server.

Large portions of this document were taken / influenced by the presentation entitled [Demand Attach / Fast-Restart Fileserver](http://workshop.openafs.org/afsbpw06/talks/tkeiser-dafs.pdf) given by Tom Keiser at the [AFS and Kerberos Best Practices Workshop](http://workshop.openafs.org/) in [2006](http://workshop.openafs.org/afsbpw06/).

## <a name="An Overview of Demand-Attach Fil"></a> An Overview of Demand-Attach File-Server

Demand-attach necessitated a significant re-design of certain aspects of the AFS code, including:

- volume package has a number of severe limitations
  - single global lock, leading to poor scaling
  - lock is held across high latency operations, e.g. disk I/O
  - no notion of state for concurrently accessed objects
- the vnode package suffers from the same limitations
- breaking callbacks is time consuming
- salvaging does not have to be done with the file-server offline

The changes implemented for demand-attach include:

- [[volume finite-state automata|AFSLore/DemandAttach#Volume_Finite_State_Automata]]
- volumes are attached on demand
- volume _garbage collector_ to detach unused volumes
- notion of volume state means read-only volumes aren't salvaged
- [[vnode finite-state automata|AFSLore/DemandAttach#Vnode_Finite_State_Automata]]
- global lock is only held when required and never held across high-latency operations
- automatic salvaging of volumes
- shutdown is done in parallel (maximum number of threads utilized)
- callbacks are no longer broken on shutdown
- instead, host / callback state is preserved across restarts

## <a name="The Gory Details of the Demand-A"></a> The Gory Details of the Demand-Attach File-Server

### <a name="File-server Start-up / Shutdown"></a><a name="File-server Start-up / Shutdown "></a> File-server Start-up / Shutdown Sequence

The table below compares the start-up sequence for a traditional file-server and a demand-attach file-server.

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <th bgcolor="#99CCCC"><strong> Traditional </strong></th>
    <th bgcolor="#99CCCC"><strong> Demand-Attach </strong></th>
  </tr>
  <tr>
    <td>   </td>
    <td> %BULLET% host / callback state restored </td>
  </tr>
  <tr>
    <td>   </td>
    <td> %BULLET% host / callback state consistency verified </td>
  </tr>
  <tr>
    <td> %BULLET% build vice partition list </td>
    <td> %BULLET% build vice partition list </td>
  </tr>
  <tr>
    <td> %BULLET% volumes are attached </td>
    <td> %BULLET% volume headers read </td>
  </tr>
  <tr>
    <td>   </td>
    <td> %BULLET% volumes placed into <em>pre-attached</em> state </td>
  </tr>
</table>

The [[host / callback state|AFSLore/DemandAttach#FSStateDat]] is covered later. The _pre-attached_ state indicates that the file-server has read the volume headers and is aware that the volume exists, but that it has not been attached (and hence is not on-line).

The shutdown sequence for both file-server types is:

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <th bgcolor="#99CCCC"><strong> Traditional </strong></th>
    <th bgcolor="#99CCCC"><strong> Demand-Attach </strong></th>
  </tr>
  <tr>
    <td> %BULLET% break callbacks </td>
    <td> %BULLET% quiesce host / callback state </td>
  </tr>
  <tr>
    <td> %BULLET% shutdown volumes </td>
    <td> %BULLET% shutdown on-line volumes </td>
  </tr>
  <tr>
    <td>   </td>
    <td> %BULLET% verify host / callback state consistency </td>
  </tr>
  <tr>
    <td>   </td>
    <td> %BULLET% save host / callback state </td>
  </tr>
</table>

On a traditional file-server, volumes are off-lined (detached) serially. In demand-attach, as many threads as possible are used to detach volumes, which is possible due to the notion of a volume has an associated state.

### <a name="Volume Finite-State Automata"></a> Volume Finite-State Automata

The volume finite-state automata is available in the source tree under `doc/arch/dafs-fsa.dot`

<a name="VolumeLeastRecentlyUsed"></a>

### <a name="Volume Least Recently Used (VLRU"></a> Volume Least Recently Used (VLRU) Queues

The Volume Least Recently Used (VLRU) is a garbage collection facility which automatically off-lines volumes in the background. The purpose of this facility is to pro-actively off-line infrequently used volumes to improve shutdown and salvage times. The process of off-lining a volume from the "attached" state to the "pre-attached" state is called soft detachment.

VLRU works in a manner similar to a generational garbage collector. There are five queues on which volumes can reside.

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <th bgcolor="#99CCCC"><strong> Queue </strong></th>
    <th bgcolor="#99CCCC"><strong> Meaning </strong></th>
  </tr>
  <tr>
    <td> candidate </td>
    <td> Volumes which have not been accessed recently and hence are candidates for soft detachment. </td>
  </tr>
  <tr>
    <td> held </td>
    <td> Volumes which are administratively prevented from VLRU activity, i.e. will never be detached. </td>
  </tr>
  <tr>
    <td> intermediate (mid) </td>
    <td> Volumes transitioning from new -&gt; old (see [[AFSLore.DemandAttach#VLRUStateTransitions][state transitions] for details). </td>
  </tr>
  <tr>
    <td> new </td>
    <td> Volumes which have been accessed. See [[AFSLore.DemandAttach#VLRUStateTransitions][state transitions] for details. </td>
  </tr>
  <tr>
    <td> old </td>
    <td> Volumes which are continually accessed. See [[AFSLore.DemandAttach.#VLRUStateTransitions][state transitions] for details. </td>
  </tr>
</table>

The state of the various VLRU queues is dumped with the file-server state and at shutdown.

<a name="VLRUStateTransitions"></a> The VLRU queues new, mid (intermediate) and old are generational queues for active volumes. State transitions are controlled by inactivity timers and are

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <th bgcolor="#99CCCC"><strong> Transition </strong></th>
    <th bgcolor="#99CCCC"><strong> Timeout (minutes) </strong></th>
    <th bgcolor="#99CCCC"><strong> Actual Timeout (in MS) </strong></th>
    <th bgcolor="#99CCCC"><strong> Reason (since last transition) </strong></th>
  </tr>
  <tr>
    <td> candidate-&gt;new </td>
    <td> - </td>
    <td> - </td>
    <td> new activity </td>
  </tr>
  <tr>
    <td> new-&gt;candidate </td>
    <td> 1 * vlruthresh </td>
    <td> 24 hrs </td>
    <td> no activity </td>
  </tr>
  <tr>
    <td> new-&gt;mid </td>
    <td> 2 * vlruthresh </td>
    <td> 48 hrs </td>
    <td> activity </td>
  </tr>
  <tr>
    <td> mid-&gt;old </td>
    <td> 4 * vlruthresh </td>
    <td> 96 hrs </td>
    <td> activity </td>
  </tr>
  <tr>
    <td> old-&gt;mid </td>
    <td> 2 * vlruthresh </td>
    <td> 48 hrs </td>
    <td> no activity </td>
  </tr>
  <tr>
    <td> mid-&gt;new </td>
    <td> 1 * vlruthresh </td>
    <td> 24 hrs </td>
    <td> no activity </td>
  </tr>
</table>

`vlruthresh` has been optimized for RO file-servers, where volumes are frequently accessed once a day and soft-detaching has little effect (RO volumes are not salvaged; one of the main reasons for soft detaching).

### <a name="Vnode Finite-State Automata"></a> Vnode Finite-State Automata

The vnode finite-state automata is available in the source tree under `doc/arch/dafs-vnode-fsa.dot`

`/usr/afs/bin/fssync-debug` provides low-level inspection and control of the file-server volume package. \*Indiscriminate use of <code>**fsync-debug**</code> can lead to extremely bad things occurring. Use with care. %ENDCOLOR%

<a name="SalvageServer"></a>

### <a name="Demand Salvaging"></a> Demand Salvaging

Demand salvaging is implemented by the `salvageserver`. The actual code for salvaging a volume remains largely unchanged. However, the method for invoking salvaging with demand-attach has changed:

- file-server automatically requests volumes be salvaged as required, i.e. they are marked as requiring salvaging when attached.
- manual initiation of salvaging may be required when access is through the `volserver` (may be addressed at some later date).
- `bos salvage` requires the `-forceDAFS` flag to initiate salvaging wit DAFS. However, %RED% **salvaging should not be initiated using this method**.%ENDCOLOR%
- infinite salvage, attach, salvage, ... loops are possible. There is therefore a hard-limit on the number of times a volume will be salvaged which is reset when the volume is removed or the file-server is restarted.
- volumes are salvaged in parallel and is controlled by the `-Parallel` argument to the `salvageserver`. Defaults to 4.
- the `salvageserver` and the `inode` file-server are incompatible:
  - because volumes are inter-mingled on a partition (rather than being separated), a lock for the entire partition on which the volume is located is held throughout. Both the `fileserver` and `volserver` will block if they require this lock, e.g. to restore / dump a volume located on the partition.
  - inodes for a particular volume can be located anywhere on a partition. Salvaging therefore results in **every** inode on a partition having to be read to determine whether it belongs to the volume. This is extremely I/O intensive and leads to horrendous salvaging performance.
- `/usr/afs/bin/salvsync-debug` provides low-level inspection and control over the `salvageserver`. %RED% **Indiscriminate use of `salvsync-debug` can lead to extremely bad things occurring. Use with care.** %ENDCOLOR%

<a name="FSStateDat"></a>

### <a name="File-Server Host / Callback Stat"></a> File-Server Host / Callback State

Host / callback information is persistent across restarts with demand-attach. On shutdown, the file-server writes the data to `/usr/afs/local/fsstate.dat`. The contents of this file are read and verified at start-up and hence it is unnecessary to break callbacks on shutdown with demand-attach.

The contents of `fsstate.dat` can be inspected using `/usr/afs/bin/state_analyzer`.

## <a name="File-Server Arguments (relating"></a><a name="File-Server Arguments (relating "></a> File-Server Arguments (relating to Demand-Attach)

These are available in the man-pages (section 8) for the fileserver; some details are provided here for convenience:

Arguments controlling the host / callback state:

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <th bgcolor="#99CCCC"><strong> Parameter </strong></th>
    <th bgcolor="#99CCCC"><strong> Options </strong></th>
    <th bgcolor="#99CCCC"><strong> Default </strong></th>
    <th bgcolor="#99CCCC"><strong> Suggested Value </strong></th>
    <th bgcolor="#99CCCC"><strong> Meaning </strong></th>
  </tr>
  <tr>
    <td><code>fs-state-dont-save</code></td>
    <td> n/a </td>
    <td> state saved </td>
    <td> - </td>
    <td><code>fileserver</code> state will not be saved during shutdown </td>
  </tr>
  <tr>
    <td><code>fs-state-dont-restore</code></td>
    <td> n/a </td>
    <td> state restored </td>
    <td> - </td>
    <td><code>fileserver</code> state will not be restored during startup </td>
  </tr>
  <tr>
    <td><code>fs-state-verify</code></td>
    <td><none %vbar%="%VBAR%" %vbar^%="%VBAR^%" both="both" restore="restore" save="save"> </none></td>
    <td> both </td>
    <td> - </td>
    <td> Controls the behavior of the state verification mechanism. Before saving or restoring the <code>fileserver</code> state information, the internal host and callback data structures are verified. A value of 'none' turns off all verification. A value of 'save' only performs the verification steps prior to saving state to disk. A value of 'restore' only performs the verification steps after restoring state from disk. A value of 'both' performs all verification steps both prior to saving and after restoring state. </td>
  </tr>
</table>

Arguments controlling the [[VLRU:|Main/WebHome#VolumeLeastRecentlyUsed]]

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <th bgcolor="#99CCCC"><strong> Parameter </strong></th>
    <th bgcolor="#99CCCC"><strong> Options </strong></th>
    <th bgcolor="#99CCCC"><strong> Default </strong></th>
    <th bgcolor="#99CCCC"><strong> Suggested Value </strong></th>
    <th bgcolor="#99CCCC"><strong> Meaning </strong></th>
  </tr>
  <tr>
    <td><code>vattachpar</code></td>
    <td> positive integer </td>
    <td> 1 </td>
    <td> 128 </td>
    <td> Controls the parallelism of the volume package start-up and shutdown routines. On start-up, vice partitions are scanned for volumes to pre-attach using a number of worker threads, the number of which is the minimum of <code>vattachpar</code> or the number of vice partitions. On shutdown, <code>vattachpar</code> worker threads are used to detach volumes. The shutdown code is mp-scaleable well beyond the number of vice partitions. Tom Keiser (from SNA) found 128 threads for a single vice partition had a statistically significant performance improvement over 64 threads. </td>
  </tr>
  <tr>
    <td><code>vhashsize</code></td>
    <td> positive integer </td>
    <td> 8 </td>
    <td> 11 </td>
    <td> This parameter controls the size of the volume hash table. The table will contain 2^( <code>vhashsize</code>) entries. Hash bucket utilization statistics are given in the <code>fileserver</code> state information as well as on shutdown. </td>
  </tr>
  <tr>
    <td><code>vlrudisable</code></td>
    <td> n/a </td>
    <td> enabled </td>
    <td> - </td>
    <td> Disables the Volume Least Recently Used (VLRU) cache. </td>
  </tr>
  <tr>
    <td><code>vlruthresh</code></td>
    <td> positive integer </td>
    <td> 120 minutes </td>
    <td> 1440 (24 hrs) </td>
    <td> Minutes of inactivity before a volume is eligible for soft detachment. </td>
  </tr>
  <tr>
    <td><code>vlruinterval</code></td>
    <td> positive integer </td>
    <td> 120 seconds </td>
    <td> - </td>
    <td> Number of seconds between VLRU candidate queue scans </td>
  </tr>
  <tr>
    <td><code>vlrumax</code></td>
    <td> positive integer </td>
    <td> 8 </td>
    <td> 8 </td>
    <td> Max number of volumes which will be soft detached in a single pass of the scanner </td>
  </tr>
</table>
