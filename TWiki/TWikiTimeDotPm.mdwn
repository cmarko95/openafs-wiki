# <a name="Package &lt;code&gt;TWiki::Time="></a> Package =TWiki::Time

Time handling functions.

<div>
  <ul>
    <li><a href="#Package =TWiki::Time="> Package TWiki::Time</a><ul>
        <li><a href="#StaticMethod <strong>parseTime</strong> ($szDat"> StaticMethod parseTime <tt>($szDate,$defaultLocal) -&gt; $iSecs</tt></a></li>
        <li><a href="#StaticMethod <strong>formatTime</strong> ($epoc"> StaticMethod formatTime <tt>($epochSeconds,$formatString,$outputTimeZone) -&gt; $value</tt></a></li>
        <li><a href="#StaticMethod <strong>formatDelta</strong> ($s)"> StaticMethod formatDelta <tt>($s) -&gt; $string</tt></a></li>
        <li><a href="#StaticMethod <strong>parseInterval</strong> ($s"> StaticMethod parseInterval <tt>($szInterval) -&gt; [$iSecs,$iSecs]</tt></a></li>
      </ul>
    </li>
  </ul>
</div>

## <a name="StaticMethod &lt;strong&gt;parseTime&lt;/strong&gt; ($szDat"></a> [[StaticMethod]] **parseTime** `($szDate,$defaultLocal) -> $iSecs`

Convert string date/time string to seconds since epoch (1970-01-01T00:00:00Z).

- `$sDate` - date/time string

Handles the following formats:

- 31 Dec 2001 - 23:59
- 2001/12/31 23:59:59
- 2001.12.31.23.59.59
- 2001/12/31 23:59
- 2001.12.31.23.59
- 2001-12-31T23:59:59

ISO dates may have a timezone specifier, either Z or a signed difference in hh:mm format. For example:

- 2001-12-31T23:59:59+01:00
- 2001-12-31T23:59Z

The default timezone is Z, unless $defaultLocal is true in which case the local timezone will be assumed.

If the date format was not recognised, will return 0.

## <a name="StaticMethod &lt;strong&gt;formatTime&lt;/strong&gt; ($epoc"></a> [[StaticMethod]] **formatTime** `($epochSeconds,$formatString,$outputTimeZone) -> $value`

- `$epochSeconds` epochSecs GMT
- `$formatString` twiki time date format, default `$day $month $year - $hour:$min`
- `$outputTimeZone` timezone to display, `gmtime` or `servertime`, default is whatever is set in $TWiki::cfg\{DisplayTimeValues\}

`$formatString` supports:

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <td> $seconds </td>
    <td> secs </td>
  </tr>
  <tr>
    <td> $minutes </td>
    <td> mins </td>
  </tr>
  <tr>
    <td> $hours </td>
    <td> hours </td>
  </tr>
  <tr>
    <td> $day </td>
    <td> date </td>
  </tr>
  <tr>
    <td> $wday </td>
    <td> weekday name </td>
  </tr>
  <tr>
    <td> $dow </td>
    <td> day number (0 = Sunday) </td>
  </tr>
  <tr>
    <td> $week </td>
    <td> week number </td>
  </tr>
  <tr>
    <td> $month </td>
    <td> month name </td>
  </tr>
  <tr>
    <td> $mo </td>
    <td> month number </td>
  </tr>
  <tr>
    <td> $year </td>
    <td> 4-digit year </td>
  </tr>
  <tr>
    <td> $ye </td>
    <td> 2-digit year </td>
  </tr>
  <tr>
    <td> $http </td>
    <td> ful HTTP header format date/time </td>
  </tr>
  <tr>
    <td> $email </td>
    <td> full email format date/time </td>
  </tr>
  <tr>
    <td> $rcs </td>
    <td> full RCS format date/time </td>
  </tr>
  <tr>
    <td> $epoch </td>
    <td> seconds since 1st January 1970 </td>
  </tr>
</table>

## <a name="StaticMethod &lt;strong&gt;formatDelta&lt;/strong&gt; ($s)"></a><a name="StaticMethod &lt;strong&gt;formatDelta&lt;/strong&gt; ($s) "></a> [[StaticMethod]] **formatDelta** `($s) -> $string`

Format a time in seconds as a string. For example, "1 day, 3 hours, 2 minutes, 6 seconds"

## <a name="StaticMethod &lt;strong&gt;parseInterval&lt;/strong&gt; ($s"></a> [[StaticMethod]] **parseInterval** `($szInterval) -> [$iSecs,$iSecs]`

Convert string representing a time interval to a pair of integers representing the amount of seconds since epoch for the start and end extremes of the time interval.

- `$szInterval` - time interval string

in yacc syntax, grammar and actions:

    interval ::= date                 { $$.start = fillStart($1); $$.end = fillEnd($1); }
             | date '/' date          { $$.start = fillStart($1); $$.end = fillEnd($3); }
             | 'P' duration '/' date  { $$.start = fillEnd($4)-$2; $$.end = fillEnd($4); }
             | date '/' 'P' duration  { $$.start = fillStart($1); $$.end = fillStart($1)+$4; }
             ;

an `interval` may be followed by a timezone specification string (this is not supported yet).

`duration` has the form (regular expression):

       P(<number><nameOfDuration>)+

nameOfDuration may be one of:

- y(year), m(month), w(week), d(day), h(hour), M(minute), S(second)

`date` follows ISO8601 and must include hypens. (any amount of trailing elements may be omitted and will be filled in differently on the differents ends of the interval as to include the longest possible interval):

- 2001-01-01T00:00:00
- 2001-12-31T23:59:59

timezone is optional. Default is local time.

If the format is not recognised, will return empty interval [0,0].

TODO: timezone testing, especially on non valid strings
