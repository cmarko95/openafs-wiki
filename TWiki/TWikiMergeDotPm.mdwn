# <a name="Package &lt;code&gt;TWiki::Merge="></a> Package =TWiki::Merge

Support for merging strings

<div>
  <ul>
    <li><a href="#Package =TWiki::Merge="> Package TWiki::Merge</a><ul>
        <li><a href="#StaticMethod <strong>merge2</strong> ($arev,$a,"> StaticMethod merge2 <tt>($arev,$a,$brev,$b,$sep,$session,$info)</tt></a></li>
        <li><a href="#StaticMethod <strong>simpleMerge</strong> ($a,$"> StaticMethod simpleMerge <tt>($a,$b,$sep) -&gt; \@arr</tt></a></li>
        <li><a href="#StaticMethod <strong>merge3</strong> ($arev,$a,"> StaticMethod merge3 <tt>($arev,$a,$brev,$b,$crev,$c,$sep,</tt></a></li>
      </ul>
    </li>
  </ul>
</div>

## <a name="StaticMethod &lt;strong&gt;merge2&lt;/strong&gt; ($arev,$a,"></a> [[StaticMethod]] **merge2** `($arev,$a,$brev,$b,$sep,$session,$info)`

- `$arev` - rev for $a (string)
- `$a` - first ('original') string
- `$brev` - rev for $b (string)
- `$b` - second ('new') string
- `$sep` = separator, string RE e.g. '.\*?\\n' for lines
- `$session` - TWiki object
- `$info` - data block passed to plugins merge handler. Conventionally this will identify the source of the text being merged (the source form field, or undef for the body text)

Perform a merge of two versions of the same text, using HTML tags to mark conflicts.

The granularity of the merge depends on the setting of $sep. For example, if it is `"\\n"`, a line-by-line merge will be done.

Where conflicts exist, they are marked using HTML &lt;del&gt; and &lt;ins&gt; tags. &lt;del&gt; marks content from $a while &lt;ins&gt; marks content from $b.

Non-conflicting content (insertions from either set) are not marked.

The plugins `mergeHandler` is called for each merge.

Call it like this:

    $newText = TWiki::Merge::merge2(
       $oldrev, $old, $newrev, $new, '.*?\n', $session, $info );

## <a name="StaticMethod &lt;strong&gt;simpleMerge&lt;/strong&gt; ($a,$"></a> [[StaticMethod]] **simpleMerge** `($a,$b,$sep) -> \@arr`

Perform a merge of two versions of the same text, returning an array of strings representing the blocks in the merged context where each string starts with one of "+", "-" or " " depending on whether it is an insertion, a deletion, or just text. Insertions and deletions alway happen in pairs, as text taken in from either version that does not replace text in the other version will simply be accepted.

The granularity of the merge depends on the setting of $sep. For example, if it is `"\\n"`, a line-by-line merge will be done. $sep characters are retained in the outout.

## <a name="StaticMethod &lt;strong&gt;merge3&lt;/strong&gt; ($arev,$a,"></a> [[StaticMethod]] **merge3** `($arev,$a,$brev,$b,$crev,$c,$sep,`

$session, $info )

- `$arev` - rev for common ancestor (id e.g. ver no)
- `$a` - common ancestor
- `$brev` - rev no for first derivative string (id)
- `$b` - first derivative string
- `$crev` - rev no for second derivative string (id)
- `$c` - second derivative string
- `$sep` = separator, string RE e.g. '.\*?\\n' for lines
- `$session` - TWiki object
- `$info` - data block passed to plugins merge handler. Conventionally this will identify the source of the text being merged (the source form field, or undef for the body text)

Perform a merge of two versions (b and c) of the same text, using HTML &lt;div&gt; tags to mark conflicts. a is the common ancestor.

The granularity of the merge depends on the setting of $sep. For example, if it is `".*?\\n"`, a line-by-line merge will be done.

Where conflicts exist, they are labeled using the provided revision numbers.

The plugins `mergeHandler` is called for each merge.

Here's a little picture of a 3-way merge:

a &lt;- ancestor / b c &lt;- revisions \\ / d &lt;- merged result, returned.

call it like this:

        my ( $ancestorMeta, $ancestorText ) =
            $store->readTopic( undef, $webName, $topic, $originalrev );
        $newText = TWiki::Merge::merge3(
            $ancestorText, $prevText, $newText,
            $originalrev, $rev, "new",
            '.*?\n' );
