# <a name="Package &lt;code&gt;TWiki::Templates="></a> Package =TWiki::Templates

Support for the TWiki template language.

<div>
  <ul>
    <li><a href="#Package =TWiki::Templates="> Package TWiki::Templates</a><ul>
        <li><a href="#ClassMethod <strong>new</strong> ($session)"> ClassMethod new <tt>($session)</tt></a></li>
        <li><a href="#ObjectMethod <strong>haveTemplate</strong> ($na"> ObjectMethod haveTemplate <tt>($name) -&gt; $boolean</tt></a></li>
        <li><a href="#ObjectMethod <strong>expandTemplate</strong> ($"> ObjectMethod expandTemplate <tt>($params) -&gt; $string</tt></a></li>
      </ul>
    </li>
  </ul>
</div>

The following tokens are supported by this language:

<table border="1" cellpadding="0" cellspacing="0">
  <tr>
    <td> %TMPL:P% </td>
    <td> Instantiates a previously defined template </td>
  </tr>
  <tr>
    <td> %TMPL:DEF% </td>
    <td> Opens a template definition </td>
  </tr>
  <tr>
    <td> %TMPL:END% </td>
    <td> Closes a template definition </td>
  </tr>
  <tr>
    <td> %TMPL:INCLUDE% </td>
    <td> Includes another file of templates </td>
  </tr>
</table>

Note; the template cache does not get reset during initialisation, so the haveTemplate test will return true if a template was loaded during a previous run when used with mod\_perl or speedycgi. Frustrating for the template author, but they just have to switch off the accelerators during development.

This is to all intents and purposes a singleton object. It could easily be coverted into a true singleton (template manager).

## <a name="ClassMethod &lt;strong&gt;new&lt;/strong&gt; ($session)"></a> [[ClassMethod]] **new** `($session)`

Constructor. Creates a new template database object.

- $session - session (TWiki) object

## <a name="ObjectMethod &lt;strong&gt;haveTemplate&lt;/strong&gt; ($na"></a> [[ObjectMethod]] **haveTemplate** `($name) -> $boolean`

Return true if the template exists and is loaded into the cache

## <a name="ObjectMethod &lt;strong&gt;expandTemplate&lt;/strong&gt; ($"></a> [[ObjectMethod]] **expandTemplate** `($params) -> $string`

Expand the template specified in the parameter string using `tmplP`.

Examples:

    $tmpls->expandTemplate('"blah");
    $tmpls->expandTemplate('context="view" then="sigh" else="humph"');

    ---++ ObjectMethod *tmplP* <tt>($attrs) -> $string</tt>

    Return value expanded text of the template, as found from looking
    in the register of template definitions. The attrs can contain a template
    name in _DEFAULT, and / or =context=, =then= and =else= values.

    Recursively expands any contained TMPL:P tags.

    Note that it would be trivial to add template parameters to this,
    simply by iterating over the other parameters (other than _DEFAULT, context,
    then and else) and doing a s/// in the template for that parameter value. This
    would add considerably to the power of templates. There is already code
    to do this in the MacrosPlugin.

    ---++ ObjectMethod *readTemplate* <tt>($name,$skins,$web) -> $text</tt>

    Return value: expanded template text

    Reads a template, constructing a candidate name for the template thus
       0 looks for file =$name.$skin.tmpl= (for each skin)
          0 in =templates/$web=
          0 in =templates=, look for
       0 looks for file =$name.tmpl=
          0 in =templates/$web=
          0 in =templates=, look for
       0 if a template is not found, tries in this order
          0 parse =$name= into a web name (default to $web) and a topic name and looks for this topic
          0 looks for topic =${skin}Skin${name}Template=
             0 in $web (for each skin)
             0 in =TWiki::cfg{SystemWebName}= (for each skin)
          0 looks for topic =${name}Template=
             0 in $web (for each skin)
             0 in =TWiki::cfg{SystemWebName}= (for each skin)
    In the event that the read fails (template not found, access permissions fail)
    returns the empty string ''.

    =$skin=, =$web= and =$name= are forced to an upper-case first character
    when composing user topic names.

    If template text is found, extracts include statements and fully expands them.
    Also extracts template definitions and adds them to the
    list of loaded templates, overwriting any previous definition.
